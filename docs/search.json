[
  {
    "objectID": "puzzle_1.html",
    "href": "puzzle_1.html",
    "title": "Puzzle 1: Penney’s Game",
    "section": "",
    "text": "A referee flips a coin many times. Izzy bets on the sequence HHT; Moore bets on the sequence HTH. The winner is the one whose sequence comes up first. What is the probability of each player winning?"
  },
  {
    "objectID": "puzzle_1.html#simulation-python",
    "href": "puzzle_1.html#simulation-python",
    "title": "Puzzle 1: Penney’s Game",
    "section": "Simulation (Python)",
    "text": "Simulation (Python)\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# This function will accept two sequences of 3 coins as lists of 3 single \n# characters, e.g. seq_1 = ['H', 'T', 'T'].\n# Returns True when seq_1 wins and False when seq_2 wins.\ndef penneys_game(seq_1, seq_2):\n  \n    # referee flips initial 3 coins\n    ref_seq = rng.choice(['H', 'T'], size = 3, replace = True)\n    \n    # continue playing until someone wins\n    while((ref_seq != seq_1).any() and (ref_seq != seq_2).any()):\n        \n        # if sequence doesn't match, advance 2nd/3rd coin to first two positions\n        # then re-flip third coin as a new one\n        ref_seq = np.concatenate(\n          (ref_seq[1:], rng.choice(['H', 'T'], size = 1))\n        )\n    \n    return (ref_seq == seq_1).all()\n  \n# Mean of 10000 T/F trials will be proportion of Trues, i.e. proportion of times\n# player 1 wins.\nplayer_1_win_prop = np.mean(\n    [penneys_game(['H', 'H', 'T'], ['H', 'T', 'H']) for i in range(10000)]\n)\n\nprint('Player 1 win percentage: {}'.format(player_1_win_prop * 100))\n\nPlayer 1 win percentage: 66.60000000000001"
  },
  {
    "objectID": "puzzle_1.html#why",
    "href": "puzzle_1.html#why",
    "title": "Puzzle 1: Penney’s Game",
    "section": "Why?",
    "text": "Why?\nIf your intuition is like mine, your first instinct might be to think that the two sequences should have the same chance of winning; after all, they’re each length 3, and any given sequence of 3 coin flips has a \\(1/8\\) chance of being thrown in isolation. The issue is that the coin flips in this problem do not occur in isolation.\nSuppose the referee has just flipped the first copy of H. This means that both Izzy (looking to see HHT) and Moore (looking to see HTH) have the first coin they were hoping to see in their sequences. Over the next two coin flips, there are four equally likely things to occur: HH, HT, TH, TT.\n\nIf the next two coins are TH, then Moore wins.\nIf the next two coins are HT, then Izzy wins.\nIf the next two coins are HH, then Izzy is guaranteed to eventually win. No matter how many more consecutive H’s are thrown, there will eventually be a T, and at that point the sequence will end with HHT; since Moore needs that same T and also an H behind it, it is not possible for HTH to appear before HHT in this scenario.\nIf the next two coins are TT, then both players are starting back from the beginning, effectively waiting for their first throw of heads.\n\nSince one of the four scenarios results in the process starting over, we can discard it; Izzy wins in 2 of the remaining 3 scenarios, so Izzy’s win probability is \\(2/3\\)."
  },
  {
    "objectID": "monte_carlo_lab.html",
    "href": "monte_carlo_lab.html",
    "title": "The Monte Carlo Laboratory",
    "section": "",
    "text": "PhD in Probability Theory (2013)\nRepresentative sample of dissertation:"
  },
  {
    "objectID": "monte_carlo_lab.html#dice-problem-take-1",
    "href": "monte_carlo_lab.html#dice-problem-take-1",
    "title": "The Monte Carlo Laboratory",
    "section": "Dice problem: take 1",
    "text": "Dice problem: take 1\n\nProblem: You roll ten standard dice. What is the probability that between two and four of them (inclusively) land on six?\n\n\n\\(\\quad \\binom{10}{2} \\left(\\frac 1 6 \\right)^2 \\left(\\frac 5 6 \\right)^8 +  \\binom{10}{3} \\left(\\frac 1 6 \\right)^3 \\left(\\frac 5 6 \\right)^7 +  \\binom{10}{4} \\left(\\frac 1 6 \\right)^4 \\left(\\frac 5 6 \\right)^6\\)\n\\(= \\frac{3,359,375}{6,718,464} \\approx \\fbox{0.5000}\\)"
  },
  {
    "objectID": "monte_carlo_lab.html#monte-carlo-simulations-an-introduction",
    "href": "monte_carlo_lab.html#monte-carlo-simulations-an-introduction",
    "title": "The Monte Carlo Laboratory",
    "section": "Monte Carlo simulations: an introduction",
    "text": "Monte Carlo simulations: an introduction\nIdea: Estimate probability by simulating experiment many times\n\nfor i = 1 to 10,000:\n  roll 10 virtual dice\n  count number of sixes as n\n  if n is between 2 and 4, record TRUE; else, FALSE\n  \nestimated prob = proportion of TRUE values out of 10,000"
  },
  {
    "objectID": "monte_carlo_lab.html#dice-problem-take-2",
    "href": "monte_carlo_lab.html#dice-problem-take-2",
    "title": "The Monte Carlo Laboratory",
    "section": "Dice problem: take 2",
    "text": "Dice problem: take 2\n\nProblem: You roll ten standard dice. What is the probability that between two and four of them (inclusively) land on six?\n\nTheoretically-derived answer: \\(\\frac{3,359,375}{6,718,464} \\approx \\fbox{0.5000}\\)\n\n\nimport matplotlib.pyplot as plt\nplt.style.use('dark_background')\nplt.rcParams.update({'font.size': 22})\n\nfrom scipy.stats import norm\n\n\nimport numpy as np\nrng = np.random.default_rng()\n\ndef ten_dice_problem():\n    die_rolls = np.array([rng.integers(1, 7) for i in range(10)]) \n    num_sixes = sum(die_rolls == 6)               # count sixes in die_rolls\n    return (num_sixes >= 2) and (num_sixes <= 4)  # output is T or F\n  \nprint(np.mean([ten_dice_problem() for i in range(10000)]))\n\n0.4992"
  },
  {
    "objectID": "monte_carlo_lab.html#a-mathematical-laboratory",
    "href": "monte_carlo_lab.html#a-mathematical-laboratory",
    "title": "The Monte Carlo Laboratory",
    "section": "A Mathematical Laboratory",
    "text": "A Mathematical Laboratory\nBenefits of Monte Carlo simulations:\n\n\n\ngives quick way to check work\nsharpens thinking about probability questions\nprovides accessible entry point to field\nprogramming puzzles are fun"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-1",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-1",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 1",
    "text": "Central Limit Theorem, take 1\n\n\nProblem: You roll \\(n\\) standard dice; let \\(X\\) be the number of them that land on 6. What is the probability distribution of \\(X\\)?\n\n\n\ndef plot_sixes_count(n_dice, show_curve):\n  \n    # reset random number generator (for reproducibility on graphs)\n    # this particularly matters for the two n = 50 graphs where I want\n    #   the same graph repeated but with a normal density grafted on\n    rng = np.random.default_rng(seed=6538)  \n    \n    def count_sixes(n_dice):\n        die_rolls = np.array([rng.integers(1, 7) for i in range(n_dice)])\n        return sum(die_rolls == 6)\n  \n    fig, ax = plt.subplots(figsize = (10, 3))\n    x_range = np.linspace(-0.5, n_dice + 0.5, num = n_dice + 2)\n    x_range_full = np.linspace(-0.5, n_dice + 0.5, num=1000)\n    \n    # histogram of sixes among 10K die rolls\n    ax.hist([count_sixes(n_dice) for i in range(10000)],\n            bins = x_range, edgecolor = 'black')\n    \n    # overlay curve (if needed)\n    if show_curve:\n        norm_mean = 1/6 * n_dice\n        norm_sd = (n_dice * 1/6 * 5/6) ** (1/2)\n        ax.plot(x_range_full, \n                norm.pdf(x_range_full, norm_mean, norm_sd) * 10000,\n                color = 'yellow')\n        \n    # set general options and plot    \n    ax.set_title('Simulations: rolling ' + str(n_dice) + ' dice')\n    ax.set_xlabel('Number of sixes rolled')\n    ax.set_ylabel('Trials (/10K)')\n    plt.show()\n    \nplot_sixes_count(1, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-1-1",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-1-1",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 1",
    "text": "Central Limit Theorem, take 1\n\n\nProblem: You roll \\(n\\) standard dice; let \\(X\\) be the number of them that land on 6. What is the probability distribution of \\(X\\)?\n\n\nplot_sixes_count(2, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-1-2",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-1-2",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 1",
    "text": "Central Limit Theorem, take 1\n\n\nProblem: You roll \\(n\\) standard dice; let \\(X\\) be the number of them that land on 6. What is the probability distribution of \\(X\\)?\n\n\nplot_sixes_count(5, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-1-3",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-1-3",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 1",
    "text": "Central Limit Theorem, take 1\n\n\nProblem: You roll \\(n\\) standard dice; let \\(X\\) be the number of them that land on 6. What is the probability distribution of \\(X\\)?\n\n\nrng = np.random.default_rng(seed=6538) # for reproducibility / next slide\nplot_sixes_count(20, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-1-4",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-1-4",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 1",
    "text": "Central Limit Theorem, take 1\n\n\nProblem: You roll \\(n\\) standard dice; let \\(X\\) be the number of them that land on 6. What is the probability distribution of \\(X\\)?\n\n\nrng = np.random.default_rng(seed=6538)\nplot_sixes_count(50, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-1-5",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-1-5",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 1",
    "text": "Central Limit Theorem, take 1\n\n\nProblem: You roll \\(n\\) standard dice; let \\(X\\) be the number of them that land on 6. What is the probability distribution of \\(X\\)?\n\n\nplot_sixes_count(50, True)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-2",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-2",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 2",
    "text": "Central Limit Theorem, take 2\n\nFrom the famous California Housing dataset:\n\nfrom sklearn.datasets import fetch_california_housing\nhousing = fetch_california_housing(as_frame=True)\n\n\nfig, ax = plt.subplots(figsize = (10, 4))\nax.hist(housing.frame.MedHouseVal, edgecolor='black', bins=20)\nax.set_title('California House Values')\nax.set_xlabel('Value (100K $)')\nax.set_ylabel('Count')\nplt.show()"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-2-1",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-2-1",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 2",
    "text": "Central Limit Theorem, take 2\n\n\nConsider a random sample of \\(n\\) California house values. What is the distribution of the sample average?\n\n\nfrom statistics import stdev\n\ndef sample_houses(n_houses, seed):\n    chosen_values = housing.frame.MedHouseVal.sample(n_houses, random_state=seed)\n    return chosen_values.mean()\n  \ndef plot_sample_houses(n_houses, show_curve):\n    fig, ax = plt.subplots(figsize=(10, 3))\n    \n    # draw 10K copies of sample of appropriate size\n    sample_means = [sample_houses(n_houses, i) for i in range(1000)]\n    x_range = (min(sample_means), max(sample_means))\n    bin_width = (x_range[1] - x_range[0]) / 20\n    \n    # make histogram\n    ax.hist(sample_means, edgecolor='black', bins=20)\n\n    # draw curve, if requested\n    if show_curve:\n        norm_mean = housing.frame.MedHouseVal.mean()\n        norm_sd = stdev(housing.frame.MedHouseVal) / (n_houses) ** (1/2)\n        x_range_linspace = np.linspace(x_range[0], x_range[1], num=1000)\n        ax.plot(x_range_linspace,\n                norm.pdf(x_range_linspace, norm_mean, norm_sd) * 1000 * bin_width,\n                color='yellow')\n    \n    # plot options\n    ax.set_title('Sample avg. of ' + str(n_houses) + ' house(s)')\n    ax.set_xlabel('Mean value (100K $)')\n    ax.set_ylabel('Trials (/1K)')\n    plt.show()\n\n\nplot_sample_houses(1, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-2-2",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-2-2",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 2",
    "text": "Central Limit Theorem, take 2\n\n\nConsider a random sample of \\(n\\) California house values. What is the distribution of the sample average?\n\n\nplot_sample_houses(2, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-2-3",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-2-3",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 2",
    "text": "Central Limit Theorem, take 2\n\n\nConsider a random sample of \\(n\\) California house values. What is the distribution of the sample average?\n\n\nplot_sample_houses(10, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-2-4",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-2-4",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 2",
    "text": "Central Limit Theorem, take 2\n\n\nConsider a random sample of \\(n\\) California house values. What is the distribution of the sample average?\n\n\nplot_sample_houses(100, False)"
  },
  {
    "objectID": "monte_carlo_lab.html#central-limit-theorem-take-2-5",
    "href": "monte_carlo_lab.html#central-limit-theorem-take-2-5",
    "title": "The Monte Carlo Laboratory",
    "section": "Central Limit Theorem, take 2",
    "text": "Central Limit Theorem, take 2\n\n\nConsider a random sample of \\(n\\) California house values. What is the distribution of the sample average?\n\n\nplot_sample_houses(100, True)"
  },
  {
    "objectID": "monte_carlo_lab.html#a-benign-looking-question",
    "href": "monte_carlo_lab.html#a-benign-looking-question",
    "title": "The Monte Carlo Laboratory",
    "section": "A Benign-Looking Question",
    "text": "A Benign-Looking Question\n\nSuppose you randomly draw letters one at a time (without replacement) until the first time you draw one out of order, after which you stop. What is the expected number of letters you will draw?\n\n\nExample: If you draw B \\(\\rightarrow\\) G \\(\\rightarrow\\) W \\(\\rightarrow\\) K, then you have stopped after 4 letters."
  },
  {
    "objectID": "monte_carlo_lab.html#a-benign-looking-solution",
    "href": "monte_carlo_lab.html#a-benign-looking-solution",
    "title": "The Monte Carlo Laboratory",
    "section": "A Benign-Looking Solution",
    "text": "A Benign-Looking Solution\n\nSuppose you randomly draw letters one at a time (without replacement) until the first time you draw one out of order, after which you stop. What is the expected number of letters you will draw?\n\n\n# for reproducibility, which in this context is just me being obsessive about\n# storytelling\nrng = np.random.default_rng(seed=5920)\n\n\ndef letters_draw():\n    rand_abc = rng.permutation(26)        # rearrangement of 0-25\n    i = 1                                 # to iterate through rand_abc\n    while(rand_abc[i] > rand_abc[i-1]):\n        i += 1                            # keep scanning until misordered\n    return i + 1                          # account for zero-index shift"
  },
  {
    "objectID": "monte_carlo_lab.html#the-solution-in-action",
    "href": "monte_carlo_lab.html#the-solution-in-action",
    "title": "The Monte Carlo Laboratory",
    "section": "The Solution in Action",
    "text": "The Solution in Action\n\nSuppose you randomly draw letters one at a time (without replacement) until the first time you draw one out of order, after which you stop. What is the expected number of letters you will draw?\n\n\ntrial_results = [letters_draw() for i in range(10000)]\n\nfig, ax = plt.subplots(figsize=(10, 3))\nax.hist(trial_results,\n        bins=np.linspace(1.5, max(trial_results) + 0.5, num=max(trial_results)),\n        edgecolor='black')\nax.set_xlabel('Number of letters drawn')\nax.set_ylabel('Simulations (/10K)')\nax.set_title('Results of letters_draw()')\nplt.show()"
  },
  {
    "objectID": "monte_carlo_lab.html#answering-the-question",
    "href": "monte_carlo_lab.html#answering-the-question",
    "title": "The Monte Carlo Laboratory",
    "section": "Answering the Question",
    "text": "Answering the Question\n\nSuppose you randomly draw letters one at a time (without replacement) until the first time you draw one out of order, after which you stop. What is the expected number of letters you will draw?\n\n\nprint(np.mean([letters_draw() for i in range(10000)]))\n#   \"Wait... is the true answer just e (2.71828...)?\"\n\n2.7297\n\n\n\n\nprint(np.mean([letters_draw() for i in range(10000)]))\n\n2.7088\n\n\n\n\n\nprint(np.mean([letters_draw() for i in range(10000)]))\n\n2.7063\n\n\n\n\n\nprint(np.mean([letters_draw() for i in range(int(1e5))]))\n\n2.71595\n\n\n\n\n\nprint(np.mean([letters_draw() for i in range(int(1e6))]))\n\n2.717787"
  },
  {
    "objectID": "monte_carlo_lab.html#the-theoretical-answer",
    "href": "monte_carlo_lab.html#the-theoretical-answer",
    "title": "The Monte Carlo Laboratory",
    "section": "The Theoretical Answer",
    "text": "The Theoretical Answer\n\n\n\\(\\mathbb E[N] = \\mathbb E \\left[1 + 1 + 1_{1 < 2} + 1_{1 < 2 < 3} + \\dots + 1_{1 < \\dots < 25} \\right]\\)\n\n\n\\(\\phantom{\\mathbb E[N]} = 1 + 1 + \\mathbb E \\left[1_{1 < 2} \\right] + \\mathbb E \\left[1_{1 < 2 < 3} \\right] + \\dots + \\mathbb E \\left[1_{1 < \\dots < 25} \\right]\\)\n\n\n\\(\\phantom{\\mathbb E[N]} = 1 + 1 + \\frac 1 2 + \\frac 1 {3!} + \\dots + \\frac 1 {25!}\\)\n\n\n\\(\\phantom{\\mathbb E[N]} = \\frac{1}{0!} + \\frac{1}{1!} + \\frac 1 2 + \\frac 1 {3!} + \\dots + \\frac 1 {25!} = \\sum_{k=0}^{25} \\frac{1}{k!}\\)"
  },
  {
    "objectID": "monte_carlo_lab.html#the-theoretical-answer-1",
    "href": "monte_carlo_lab.html#the-theoretical-answer-1",
    "title": "The Monte Carlo Laboratory",
    "section": "The Theoretical Answer",
    "text": "The Theoretical Answer\n\n\n\\(\\mathbb E[N] = \\sum_{k=0}^{25} \\frac 1 {k!}\\)\n\\(e = \\sum_{k = 0}^{\\infty} \\frac 1 {k!}\\)\ndifference: \\(\\sum_{k = 26}^{\\infty} \\frac 1 {k!}\\)\n\n\n\n\nfrom math import factorial\nprint(\"E[N] = {}\".format(sum([1 / factorial(k) for k in range(26)])))\nprint(\"   e = {}\".format(np.exp(1)))\n\nE[N] = 2.7182818284590455\n   e = 2.718281828459045\n\n\n\n\n\nprint(\"diff = {}\".format(sum([1 / factorial(k) for k in range(26, 1000)])))\n\ndiff = 2.574830046247861e-27"
  },
  {
    "objectID": "monte_carlo_lab.html#monte-carlo-vs.-theoretical-probability",
    "href": "monte_carlo_lab.html#monte-carlo-vs.-theoretical-probability",
    "title": "The Monte Carlo Laboratory",
    "section": "Monte Carlo vs. Theoretical Probability?",
    "text": "Monte Carlo vs. Theoretical Probability?\n\nAdvantages of the Monte Carlo approach:\n\n\npermits laboratory-like exploration\nallows progress where theory fails\n\n\n\n\nAdvantages of the theoretical approach:\n\n\nlets us state and prove theorems\nreveals the why\n\n\n\n\nThe best thing to have is… BOTH!"
  },
  {
    "objectID": "monte_carlo_lab.html#puzzle-1-penneys-game",
    "href": "monte_carlo_lab.html#puzzle-1-penneys-game",
    "title": "The Monte Carlo Laboratory",
    "section": "Puzzle 1: Penney’s Game",
    "text": "Puzzle 1: Penney’s Game\n\nA referee flips a coin many times. Izzy bets on the sequence HHT; Moore bets on the sequence HTH. The winner is the one whose sequence comes up first. What is the probability of each player winning?\n\n\n\nHTTHTTTHTH\n\n\n\nAnswer: not 50/50"
  },
  {
    "objectID": "monte_carlo_lab.html#puzzle-2-bag-of-candies",
    "href": "monte_carlo_lab.html#puzzle-2-bag-of-candies",
    "title": "The Monte Carlo Laboratory",
    "section": "Puzzle 2: Bag of candies",
    "text": "Puzzle 2: Bag of candies\n\nI have a bag that contains 20 Skittles and 100 M&Ms. Each day, I draw one candy, note its type, and eat it. I then continue drawing candies and eating them so long as they’re the same type – but when I draw one of the other type, I put it back and stop for the day.\nWhat is the probability that the last candy will be a Skittle?\n\n\nAnswer: not what I first guessed"
  },
  {
    "objectID": "monte_carlo_lab.html#qr-code",
    "href": "monte_carlo_lab.html#qr-code",
    "title": "The Monte Carlo Laboratory",
    "section": "QR code",
    "text": "QR code\nGitHub page should have: questions, simulation solutions, and the mathematical proofs"
  },
  {
    "objectID": "puzzle_2.html",
    "href": "puzzle_2.html",
    "title": "Puzzle 2: Bag of Candies",
    "section": "",
    "text": "I have a bag that contains 20 Skittles and 100 M&Ms. Each day, I draw one candy, note its type, and eat it. I then continue drawing candies and eating them so long as they’re the same type – but when I draw one of the other type, I put it back and stop for the day.\nWhat is the probability that the last candy will be a Skittle?"
  },
  {
    "objectID": "puzzle_2.html#simulation-python",
    "href": "puzzle_2.html#simulation-python",
    "title": "Puzzle 2: Bag of Candies",
    "section": "Simulation (Python)",
    "text": "Simulation (Python)\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# This function will simulate depletion of one entire bag of candies and will\n# return True if the last candy is a Skittle. The `list.pop()` method is used\n# extensively; this method returns the value of a list at a given index while\n# simultaneously deleting that value from the list. It's also delightful to be\n# able to \"pop\" a candy.\ndef bag_of_candies(n_skittles, n_mms):\n    \n    bag = ['S'] * n_skittles + ['M'] * n_mms\n    \n    # starting with bag (a long list), remove items until only one is left\n    while(len(bag) > 1):\n      \n        # set today's acceptable candy to eat (and remove it from bag)\n        current_candy = bag.pop(rng.integers(len(bag)))\n        \n        # draw next candy without removing it (yet)\n        next_draw_position = rng.integers(len(bag))\n        \n        # continue drawing and removing candies, but only of the right type\n        while(bag[next_draw_position] == current_candy and len(bag) > 1):\n            bag.pop(next_draw_position)\n            next_draw_position = rng.integers(len(bag))\n    \n    return bag == ['S']\n\n# Mean of 10,000 trials  \nprint('Percent of trials with a final Skittle: {}'\n      .format(np.mean([bag_of_candies(20, 100) for i in range(10000)]) * 100)\n      )\n\nPercent of trials with a final Skittle: 50.839999999999996"
  },
  {
    "objectID": "puzzle_2.html#why",
    "href": "puzzle_2.html#why",
    "title": "Puzzle 2: Bag of Candies",
    "section": "Why?",
    "text": "Why?\nAs the simulation suggests, your last candy has a 50/50 chance of being either a Skittle or an M&M. It should also be pretty believable that the number of M&M’s and Skittles involved is completely irrelevant to the question; it’s the process itself that results in a 50/50 chance for the last candy (so long as there’s at least 1 candy of each type).\nWe’ll prove this result by induction; specifically, we’ll induct on the number of candies in the bag. At each stage, we’ll assume that there is at least 1 candy of each type.\n\n\\(n = 2\\): If there are 2 candies in the bag, this means there’s 1 M&M and 1 Skittle; clearly, either one has a 50/50 chance of being the last candy drawn.\n\\(\\{2, \\dots, n\\} \\implies n + 1\\): Suppose there are \\(n + 1\\) candies in the bag. Then there are three possibilities:\n\nWe will draw all the M&M’s first without ever drawing a single Skittle; hence, the process will end on the next day and a Skittle will be last.\nWe will draw all the Skittles first without ever drawing a single M&M; hence, the process will end on the next day and an M&M will be last.\nWe will draw a few Skittles or M&M’s, but not at all of them; hence, the day will end with the bag still having a mixture of the types, but fewer of them than it did before.\n\nThe first case is equivalent to placing all \\(n + 1\\) of the candies in a random order and having all the M&M’s be at the beginning. However, the second case is equivalent to having all the M&M’s be at the end of that same random ordering. These are clearly equal by symmetry; indeed, if there are \\(k\\) M&M’s among the \\(n + 1\\) candies, then both are equal to \\(1 / \\binom {n+1}{k}\\).\nThus, either the game is destined to end in two days (with equal chance of ending on a Skittle or an M&M), or the next day will restart the game with a smaller number of total candies in the bag. But by induction, any smaller bag size has a similar eventual 50/50 fate of ending with either a Skittle or an M&M.\n\nThis induction proof almost feels like cheating, but it becomes clearer if we carefully consider the \\(n = 3\\) case. Suppose that we have three candies in the bag, which are (without loss of generality) two Skittles and one M&M. These three candies can be placed in any of three orders, each of which are equally likely:\n\n\\(M, S, S\\)\n\\(S, S, M\\)\n\\(S, M, S\\)\n\nThese correspond to the three cases above. In the first case, a Skittle will be last; in the second case, an M&M will be last. In the third case, we’ll draw one Skittle and eat it; then we’ll draw an M&M and put it back, so the bag will have one of each type for the next day’s draw. The “put it back” action is ultimately what makes this all work; this is the essential why of the problem."
  },
  {
    "objectID": "monte_carlo_lab.html#my-background",
    "href": "monte_carlo_lab.html#my-background",
    "title": "The Monte Carlo Laboratory",
    "section": "My background",
    "text": "My background\n\n\nPhD in Probability Theory (2013)\nRepresentative sample of dissertation:"
  }
]